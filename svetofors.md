# **Тестовое задание**

Рассмотрим перекресток на рисунке. На нем находится несколько светофоров, регулирующих движение автомобилей (4 шт), и
несколько - движение пешеходов по переходам (8 шт):

![](/img/scheme.png)
У пешеходных светофоров 2 состояния, у автомобильных - 3. В каждый светофор встроена камера, которая фиксирует
количество автомобилей/пешеходов в той очереди, для которых светофор установлен. Это очередь на противоположной стороне
пешехода/перекрестка (см рисунок). Автомобили при проезде перекрестка едут либо прямо, либо направо. Люди и автомобили
осуществляют переход или проезд перекрестка по одному, уменьшая размер соответствующей очереди на 1.

Каждый светофор имеет уникальный id. Светофоры могут общаться при помощи событий, отсылая события друг другу по id.
Пересылаемые события - это некоторые контейнеры с данными (например, там может лежать количество людей/автомобилей в
очереди, id отправителя, текущее состояние светофора). Светофор может взводить таймер, который через заданное время
отсылают заданное событие на заданный id. Отправка события - это помещение контейнера в очередь событий для светофора, у
каждого светофора очередь своя собственная. Светофоры обрабатывают события параллельно, независимо друг от друга. При
этом каждый светофор обрабатывает свои события последовательно, в том порядке, в каком они помещаются в очередь.
Светофор может получить информацию о текущем состоянии любого другого светофора синхронно (не через событие).

**_Задача:_** _придумать и описать адаптивный алгоритм работы светофоров для оптимизации общей пропускной способности
перекрестка в зависимости от ситуации на перекрестке._

# **Решение общего случая**

Если задание понято верно, в один момент может быть активным (пропускающим) любое количество светофоров, однако каджый светофор может пересечь только один объект(пешеход или автомобиль).

Имеем 4 автомобильные и 8 пешеходных очередей, данные о размере которых находятся в памяти светофора и обновляются каждую итерацию. Первым следует запуститься светофору с наибольшей очередью. Если это автомобильный светофор, то он переключается на желтый сигнал. Условие позволяет светофорам обмениваться информацией со всеми светофорами разом, а значит при запуске приоритет автоматически отдастся наибольшей очереди, независимо от типа объекта. Если следующий за ним светофор является автомобильным, он переключается на желтый сигнал. Включение светофора накладывает блокировку сообщением на остальные светофоры. После обратного переключения светофора происходит снова сбор и сверка размеров очередей, однако светофор, запущенный последним будет сдвинут в конец очереди. Это необходимо для "ротации" светофоров и избежания ситуаций, когда прибывающий поток объектов в наибольшую очередь блокирует все остальные очереди по правилу выше.

Также можно заметить, что светофоры могут быть собраны в неблокирующие друг друга группы. Поворот налево исключен, а значит возможен запуск одновременно двух пешеходных светофоров и одного автомобильного. В таком случае принцип приоритизации немного меняется. Вместо сравнивания каждого отдельно взятого светофора будем считать сумму объектов группы, готовых к переходу. Смысл перекрестка не в том, чтобы на нем стоять и мы стремимся к наибольшей пропускной способности, вроде бы.

Рассмотрим вариант на рисунке, чтобы удостовериться в работоспособности алгоритма.
![](/img/scheme2.png)

Пронумеруем id светофоров и соберем массив значений для обозначения очередей. В предложенном варианте получим мапу очередей формата {id: queue_size} {1: 2, 2: 1, 3: 2, 4: 3, 5: 2, 6: 0, 7: 2, 8: 2, 9: 0, 10: 0, 11: 2, 12: 0}

Сгруппировав эти значения получим 4 мапы:
    
    {
     G1 : {1: 2, 5: 2, 3: 2},
     G2 : {4: 3, 8: 2, 6: 0},
     G3 : {7: 2, 11: 2, 9: 0},
     G4 : {10: 0, 2: 1, 12: 0}
    }

Высчитав количество объектов в группе, готовых к переходу, получим:
    
    {
     G1: 3 объекта,
     G2: 2 объекта,
     G3: 2 объекта,
     G4: 1 объект
    }

Первой запустим группу 1 (Светофоры с id 1, 3, 5). В каждой из этих очередей число объектов уменьшится на 1.

Производим повторный опрос. Получаем:

    {
     G1 : {1: 1, 5: 1, 3: 1},
     G2 : {4: 3, 8: 2, 6: 0},
     G3 : {7: 2, 11: 2, 9: 0},
     G4 : {10: 0, 2: 1, 12: 0}
    }

Высчитав группы получим:
    
    {
     G1: 3 объекта,
     G2: 2 объекта,
     G3: 2 объекта,
     G4: 1 объект
    }

Ввиду того, что группа 1 уже была включена, ее следует поместить в конец очереди выполнения. Отсюда примем решение о включении группы 2 (у нее одинаковое значение с группой 3, поэтому их включение при отсутствии добавочных элементов в очереди равнозначно)

Очередь выполнения будет иметь вид:

    {
     G2: 2 объекта,
     G3: 2 объекта,
     G4: 1 объект,
     G1: 3 объекта,
    }

Производим повторный опрос. Получаем:

    {
     G1 : {1: 1, 5: 1, 3: 1},
     G2 : {4: 1, 8: 1, 6: 0},
     G3 : {7: 2, 11: 2, 9: 0},
     G4 : {10: 0, 2: 1, 12: 0}
    }

Очередь выполнения будет иметь вид:

    {
     G3: 2 объекта,
     G4: 1 объект,
     G1: 3 объекта,
     G2: 2 объекта,
    }

Упраздним дальнейшие манипуляции, тут у нас не лонгрид. Принцип работы алгоритма ясен, решение для общего случая считаем удовлетворительным.

# **Решение краевых случаев**

Главным аспектом этого алгоритма по условию является адаптивность, отсюда делаем вывод о необходимости дополнительных режимов работы.

Я смог выделить два основных краевых случая для этой конструкции - наличие только пешеходов и только машин.

В обоих случаях принцип состоит в следующем: при наличии в очередях объектов разных типов группируем светофоры нужного типа и расширяем их логику.

Для пешеходных светофоров решение состоит в одновременном включении всех светофоров для перехода людей до момента появления машины на перекрестке (опрос проводится каждый переход, держим в уме.)

Для автомобильных светофоров группировка будет по принципу прямой линии (поворот налево отключен, а значит встречные направления могут работать одновременно.)
Приоритизация будет той же, считаем количество объектов готовых к пересечению перекрестка и включаем группы светофоров, опираясь на ротацию.


# **Заключение**

В теории, принцип работы алгоритма описан достаточно подробно, однако остается место для поиска оптимальных структур данных, к примеру для хранения очередей и алгоритмов для вычисления максимума. Также стоило бы задуматься о наличии бэкапа в энергонезависимой памяти (или брокера очередей), который хранит очереди светофоров на случай отключения питания.

Программную реализацию предложить не успеваю, прошу прощения.

Буду рад получить развернутую обратную связь. В качестве проверки, если вы дочитали это, пожалуйста, напишите в начале ответа GIT GUD.